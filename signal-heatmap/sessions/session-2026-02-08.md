# Session 2026-02-08 — Signal Heatmap

## Overview

Built the signal-heatmap app from scratch: a walk-around WiFi signal mapper that uses device motion sensors for automatic position tracking and renders signal quality as a colored heatmap on a canvas.

## Implementation Decisions

### Dead Reckoning via Accelerometer + Compass
- Step detection uses accelerometer magnitude (`sqrt(x^2+y^2+z^2)`) with a moving-average low-pass filter (window size 5) and peak detection above a configurable threshold (default 12 m/s^2)
- 300ms debounce prevents double-counting a single step
- Compass heading from `deviceorientation` (with iOS `webkitCompassHeading` fallback) determines direction
- Each step advances position by `stepLength` pixels in the heading direction

### Manual Tap Mode Fallback
- Desktop browsers lack motion sensors, so tapping the canvas places the position dot and auto-triggers a WiFi measurement
- This fallback also activates when sensor permission is denied on iOS
- Same heatmap visualization works in both modes

### WiFi Scoring
- Directly ported from wifi-helper: dual-mode scoring (Network Info API + CDN speed test)
- 40pts downlink + 30pts RTT + 30pts speed test when API available
- 100% speed test fallback when Network Info API is absent (Safari, Firefox)

### Heatmap Rendering
- Each measurement renders as a radial gradient: solid center fading to transparent at the configured radius
- Color interpolation: score 0-50 maps red to yellow, 50-100 maps yellow to green
- Semi-transparent gradients (0.6 alpha at center) blend naturally at overlaps
- Canvas uses DPR-aware sizing for crisp rendering on Retina displays

### Persistence
- Measurements, path trace, and settings all persist in localStorage with distinct keys
- Position restores to last known path point on reload
- Status bar restores from last measurement

## Architecture

- `state` object holds all runtime state (position, measurements, path, flags)
- `accel` object holds accelerometer filter state separately
- Settings read from UI inputs on change, persisted immediately
- Canvas redraws fully on each state change (grid → heatmap → path → position)
- Single `pointerdown` event handles both touch and mouse interaction

## Lessons Learned

- iOS requires explicit `DeviceMotionEvent.requestPermission()` triggered by user gesture — must show a permission button before sensors work
- `deviceorientation` alpha values are inverted on some Android devices, so `(360 - alpha) % 360` is used as a reasonable cross-platform approximation
- Canvas `aspect-ratio: 1` CSS property combined with `max-height: 70vh` gives a good mobile layout without JavaScript dimension calculations
